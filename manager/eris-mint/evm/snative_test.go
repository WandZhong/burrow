package vm

import (
	"encoding/hex"
	"testing"

	. "github.com/eris-ltd/eris-db/word256"
	"github.com/stretchr/testify/assert"
	"fmt"
	. "github.com/eris-ltd/eris-db/manager/eris-mint/evm/opcodes"
	ptypes "github.com/eris-ltd/eris-db/permission/types"
)

/* Compiling the Permissions solidity contract at
(generated by Solidity() function)
https://ethereum.github.io/browser-solidity yields:

Functions
3fbf7da5 add_role(address,bytes32)
744f5998 has_base(address,uint64)
e8145855 has_role(address,bytes32)
28fd0194 rm_role(address,bytes32)
3f0ebb30 set_base(address,uint64,uint64)
d54a562d set_global(uint64,uint64)
73448c99 unset_base(address,uint64)

*/

func TestPermissionsContractSignatures(t *testing.T) {
	contract := SNativeContracts()["permissions_contract"]

	assertFunctionIDSignature(t, contract, "3fbf7da5",
		"add_role(address,bytes32)")

	assertFunctionIDSignature(t, contract, "744f5998",
		"has_base(address,uint64)")

	assertFunctionIDSignature(t, contract, "e8145855",
		"has_role(address,bytes32)")

	assertFunctionIDSignature(t, contract, "28fd0194",
		"rm_role(address,bytes32)")

	assertFunctionIDSignature(t, contract, "3f0ebb30",
		"set_base(address,uint64,uint64)")

	assertFunctionIDSignature(t, contract, "d54a562d",
		"set_global(uint64,uint64)")

	assertFunctionIDSignature(t, contract, "73448c99",
		"unset_base(address,uint64)")
}

func TestSNativeContractDescription_Dispatch(t *testing.T) {
	contract := SNativeContracts()["permissions_contract"]
	state := newAppState()
	caller := &Account{
		Address: addr(1,1,1),
	}
	grantee := &Account{
		Address: addr(2,2,2),
	}
	state.UpdateAccount(grantee)

	function, err := contract.FunctionByName("add_role")
	if err != nil {
		t.Fatalf("Could not get function: %s", err)
	}
	funcID := function.ID()
	gas := int64(1000)

	retValue, err := contract.Dispatch(state, caller, Bytecode(funcID[:],
		grantee.Address, permFlagToWord256(ptypes.CreateAccount)), &gas)
	assert.Error(t, err)
	if err != nil {
		assert.Contains(t, err.Error(), "does not have permission")
	}

	caller.Permissions = allAccountPermissions()
	retValue, err = contract.Dispatch(state, caller, Bytecode(funcID[:],
		grantee.Address, permFlagToWord256(ptypes.CreateAccount)), &gas)
	assert.NoError(t, err)
	assert.Equal(t, retValue, LeftPadBytes([]byte{1},32))
}

func TestSNativeFuncTemplate(t *testing.T) {
	contract := SNativeContracts()["permissions_contract"]
	function, err := contract.FunctionByName("rm_role")
	if err != nil {
		t.Fatal("Couldn't get function")
	}
	solidity, err := function.Solidity()
	assert.NoError(t, err)
	fmt.Println(solidity)
}

// This test checks that we can generate the SNative contract interface and
// prints it to stdout
func TestSNativeContractTemplate(t *testing.T) {
	contract := SNativeContracts()["permissions_contract"]
	solidity, err := contract.Solidity()
	assert.NoError(t, err)
	fmt.Println(solidity)
}

//
// Helpers
//
func assertFunctionIDSignature(t *testing.T, contract SNativeContractDescription,
	funcIDHex string, expectedSignature string) {
	function, err := contract.FunctionByID(funcIDFromHex(t, funcIDHex))
	assert.NoError(t, err,
		"Error retrieving SNativeFunctionDescription with ID %s", funcIDHex)
	if err == nil {
		assert.Equal(t, expectedSignature, function.Signature())
	}
}

func funcIDFromHex(t *testing.T, hexString string) FuncID {
	bs, err := hex.DecodeString(hexString)
	assert.NoError(t, err, "Could not decode hex string '%s'", hexString)
	if len(bs) != 4 {
		t.Fatalf("FuncID must be 4 bytes but '%s' is %v bytes", hexString,
			len(bs))
	}
	return firstFourBytes(bs)
}

func permFlagToWord256(permFlag ptypes.PermFlag) Word256 {
	return Uint64ToWord256(uint64(permFlag))
}

func addr(rightBytes... uint8) Word256 {
	return LeftPadWord256(rightBytes)
}

func allAccountPermissions() ptypes.AccountPermissions {
	return ptypes.AccountPermissions{
		Base: ptypes.BasePermissions{
			Perms:  ptypes.AllPermFlags,
			SetBit: ptypes.AllPermFlags,
		},
		Roles: []string{},
	}
}